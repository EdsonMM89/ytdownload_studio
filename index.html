<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YTDOWNLOAD Studio (Sintaxis Estricta)</title>
    <style>
        :root {
            --color-bg-darkest: #101010;
            --color-bg-dark: #1e1e1e;
            --color-bg-sidebar: #191919;
            --color-consola-bg: #151515;
            --color-texto: #e0e0e0;
            --color-texto-secundario: #888;
            --color-verde: #00ff41;
            --color-rojo: #e53935;
            --color-azul: #41a6ff;
            --color-amarillo: #f0f000;
            --color-borde: #2a2a2a;
            --color-rojo-btn: #d32f2f;
            --color-rojo-btn-hover: #e53935;
        }

        html, body {
            height: 100%;
            margin: 0;
            font-family: 'Consolas', 'Monaco', monospace;
            background-color: var(--color-bg-darkest);
            color: var(--color-texto);
            overflow: hidden;
        }

        /* --- Estructura Principal --- */
        .studio-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        header {
            background-color: var(--color-bg-darkest);
            border-bottom: 1px solid var(--color-borde);
            padding: 10px 20px;
            font-size: 1.2em;
            font-weight: bold;
            color: var(--color-texto);
            flex-shrink: 0;
        }

        .main-content {
            display: flex;
            flex-grow: 1;
            overflow: hidden; /* Evita scroll en el main */
        }

        /* --- Panel Izquierdo (Editor + Consola) --- */
        .left-pane {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            background-color: var(--color-bg-dark);
            height: 100%; /* Ocupa todo el alto disponible */
        }

        .editor-wrapper {
            flex: 60; /* 60% del espacio */
            position: relative;
        }

        #editor {
            width: 100%;
            height: 100%;
            background-color: var(--color-bg-dark);
            color: var(--color-texto);
            border: none;
            padding: 15px;
            font-family: inherit;
            font-size: 1.1em;
            line-height: 1.6;
            resize: none;
            outline: none;
            box-sizing: border-box; /* Importante */
        }

        .controls-bar {
            flex-shrink: 0;
            display: flex;
            align-items: center;
            padding: 10px 15px;
            background-color: var(--color-bg-dark);
            border-top: 1px solid var(--color-borde);
            border-bottom: 1px solid var(--color-borde);
        }

        #run-button {
            background-color: var(--color-rojo-btn);
            color: #fff;
            border: none;
            padding: 8px 15px;
            font-family: inherit;
            font-size: 0.9em;
            font-weight: bold;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #run-button:hover {
            background-color: var(--color-rojo-btn-hover);
        }

        #status-text {
            margin-left: 15px;
            font-size: 0.9em;
            color: var(--color-texto-secundario);
        }
        #status-text.error {
            color: var(--color-rojo);
            font-weight: bold;
        }
        #status-text.success {
            color: var(--color-verde);
            font-weight: bold;
        }


        .console-wrapper {
            flex: 40; /* 40% del espacio */
            display: flex;
            flex-direction: column;
            background-color: var(--color-consola-bg);
            font-size: 1.1em;
            overflow-y: hidden;
            padding: 15px;
            box-sizing: border-box;
        }

        #console-output {
            flex-grow: 1;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        /* Clases de líneas de la consola */
        #console-output .line { margin-bottom: 5px; }
        #console-output .line-error { color: var(--color-rojo); font-weight: bold; }
        #console-output .line-success { color: var(--color-verde); font-weight: bold; }
        #console-output .line-info { color: var(--color-azul); font-weight: bold; }
        #console-output .line-warn { color: var(--color-amarillo); font-weight: bold; }
        #console-output .line-cmd { color: var(--color-texto-secundario); }
        #console-output .line-sim-output { color: var(--color-texto); }
        #console-output .line-sim-prompt { display: none; }

        .input-line {
            display: flex;
            flex-shrink: 0;
            background-color: var(--color-consola-bg);
        }

        .prompt {
            color: var(--color-verde);
            margin-right: 8px;
            flex-shrink: 0;
            white-space: pre; /* Respeta espacios en el prompt */
        }

        #console-input {
            flex-grow: 1;
            background: transparent;
            border: none;
            color: var(--color-verde);
            font-family: inherit;
            font-size: inherit;
            outline: none;
            padding: 0;
        }
        
        .cursor {
            display: inline-block;
            background-color: var(--color-verde);
            width: 10px;
            height: 1.2em;
            animation: blink 1s step-end infinite;
            vertical-align: bottom;
            margin-left: 2px;
        }
        @keyframes blink {
            from, to { background-color: transparent }
            50% { background-color: var(--color-verde) }
        }


        /* --- Panel Derecho (Sidebar) --- */
        .right-pane {
            flex-basis: 250px; /* Ancho fijo */
            flex-shrink: 0;
            background-color: var(--color-bg-sidebar);
            border-left: 1px solid var(--color-borde);
            padding: 20px;
            overflow-y: auto;
            box-sizing: border-box;
        }
        
        .right-pane h3 {
            color: var(--color-rojo);
            margin-top: 0;
            border-bottom: 1px solid var(--color-borde);
            padding-bottom: 10px;
        }

        .file-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .file-list li {
            padding: 10px 5px;
            margin-bottom: 5px;
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.2s;
            color: var(--color-texto-secundario);
        }
        .file-list li:hover {
            background-color: #2a2a2a;
            color: var(--color-texto);
        }
        .file-list li.active {
            background-color: var(--color-rojo-btn);
            color: #fff;
            font-weight: bold;
        }

        #upload-button {
            display: block;
            width: 100%;
            padding: 10px 5px;
            margin-top: 20px;
            background-color: var(--color-borde);
            color: var(--color-texto);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            text-align: left;
            font-size: 1em;
        }
        #upload-button:hover {
            background-color: #333;
        }
        .upload-info {
            font-size: 0.8em;
            color: var(--color-texto-secundario);
            margin-top: 10px;
        }


        #file-uploader {
            display: none;
        }

    </style>
</head>
<body>

    <div class="studio-container">
        <header>YTDOWNLOAD Studio</header>
        
        <main class="main-content">
            <div class="left-pane">
                
                <div class="editor-wrapper">
                    <textarea id="editor" spellcheck="false" autocomplete="off"></textarea>
                </div>

                <div class="controls-bar">
                    <button id="run-button"> Ejecutar </button>
                    <span id="status-text">Estado: Listo</span>
                </div>

                <div class="console-wrapper" id="console-wrapper">
                    <div id="console-output"></div>
                    <div class="input-line">
                        <span class="prompt" id="prompt-text">></span>
                        <input type="text" id="console-input">
                        <span class="cursor"></span>
                    </div>
                </div>

            </div>

            <aside class="right-pane">
                <h3>Archivos</h3>
                <ul class="file-list" id="file-list">
                    </ul>

                <button id="upload-button">Subir archivo .ytd</button>
            </aside>
        </main>
    </div>
    
    <input type="file" id="file-uploader" accept=".txt">

    <script>
    // ==================================================================
    // 1. ESTADO Y DATOS INICIALES (CON SINTAXIS ESTRICTA ';')
    // ==================================================================
    
    const initialFiles = {
        'simple.ytd': 
`FUNCION main() {
    VAR link = ' ';
    IMPRIMIR 'Ingresa la URL del video:';
    LEER link;
    descargar(link,' ', 'Video1', 'C:/Videos');
} FIN!`,
        
        'playlist.ytd':
`FUNCION main() {
    VAR playlistURL = ' ';
    IMPRIMIR 'Ingresa la URL de la PLAYLIST:';
    LEER playlistURL;
    descargar(playlistURL, ' ', 'MiPlaylist', 'C:/Musica');
} FIN!`,
        
        'formatos.ytd':
`FUNCION main() {
    VAR enlaces = ['https://video1.com' AS 'Clase 1', 'https://video2.com' AS 'Proyecto'];
    VAR formato = ' ';
    IMPRIMIR 'Selecciona el formato para el lote (mp3/mp4):';
    LEER formato;
    PARA CADA e EN enlaces HACER {
        SI formato ENTONCES {
            descargar(e.url, formato, e.nombre, 'D:/Videos');
        }
    } FIN;
} FIN!`
    };

    // Estado de la aplicación
    let tabData = { ...initialFiles };
    let activeFile = 'simple.ytd';
    let consoleMode = 'command'; // 'command' | 'simulation' | 'idle'
    let currentProcess = null; // Renombrado de 'currentSimulation'
    let processInputResolve = null; // Renombrado de 'simulationInputResolve'
    let currentInputPrompt = ""; 

    // ==================================================================
    // 2. ELEMENTOS DEL DOM
    // ==================================================================
    
    const fileList = document.getElementById('file-list');
    const editor = document.getElementById('editor');
    const consoleWrapper = document.getElementById('console-wrapper');
    const consoleOutput = document.getElementById('console-output');
    const consoleInput = document.getElementById('console-input');
    const promptText = document.getElementById('prompt-text');
    const fileUploader = document.getElementById('file-uploader');
    const runButton = document.getElementById('run-button');
    const statusText = document.getElementById('status-text');
    const uploadButton = document.getElementById('upload-button');

    // ==================================================================
    // 3. ANALIZADOR LÉXICO
    // ==================================================================
    
    const TokenType = {
        FUNCION: 'FUNCION', MAIN: 'main', FIN_FUNCION: 'FIN!',
        VAR: 'VAR',
        IMPRIMIR: 'IMPRIMIR', LEER: 'LEER',
        PARA: 'PARA', CADA: 'CADA', EN: 'EN', HACER: 'HACER', FIN_PARA: 'FIN;',
        SI: 'SI', ENTONCES: 'ENTONCES',
        DESCARGAR: 'descargar',
        AS: 'AS',
        PAREN_IZQ: '(', PAREN_DER: ')',
        LLAVE_IZQ: '{', LLAVE_DER: '}',
        CORCH_IZQ: '[', CORCH_DER: ']',
        PUNTO_COMA: ';', 
        COMA: ',',
        ASIGNAR: '=',
        PUNTO: '.',
        IDENTIFICADOR: 'IDENTIFICADOR',
        STRING: 'STRING',
        TIPO_DATO: 'TIPO_DATO',
        EOF: 'EOF'
    };

    const KEYWORDS = {
        'FUNCION': TokenType.FUNCION, 'main': TokenType.MAIN, 'FIN!': TokenType.FIN_FUNCION,
        'VAR': TokenType.VAR,
        'IMPRIMIR': TokenType.IMPRIMIR, 'LEER': TokenType.LEER,
        'PARA': TokenType.PARA, 'CADA': TokenType.CADA, 'EN': TokenType.EN, 'HACER': TokenType.HACER, 'FIN;': TokenType.FIN_PARA,
        'SI': TokenType.SI, 'ENTONCES': TokenType.ENTONCES,
        'descargar': TokenType.DESCARGAR,
        'AS': TokenType.AS,
        'mp3': TokenType.TIPO_DATO, 'mp4': TokenType.TIPO_DATO, 'mkv': TokenType.TIPO_DATO, 'flac': TokenType.TIPO_DATO
    };

    function analizarLexico(code) {
        let tokens = [];
        let pos = 0;
        let linea = 1;
        let col = 1;

        const esLetra = (c) => c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c === '_';
        const esNumero = (c) => c >= '0' && c <= '9';
        const esAlfanumerico = (c) => esLetra(c) || esNumero(c);
        const esEspacio = (c) => c === ' ' || c === '\t' || c === '\r';

        while (pos < code.length) {
            let char = code[pos];

            if (esEspacio(char)) {
                pos++;
                col++;
                continue;
            }
            if (char === '\n') {
                pos++;
                linea++;
                col = 1;
                continue;
            }

            const simbolos = {
                '(': TokenType.PAREN_IZQ, ')': TokenType.PAREN_DER,
                '{': TokenType.LLAVE_IZQ, '}': TokenType.LLAVE_DER,
                '[': TokenType.CORCH_IZQ, ']': TokenType.CORCH_DER,
                ';': TokenType.PUNTO_COMA, ',': TokenType.COMA,
                '=': TokenType.ASIGNAR, '.': TokenType.PUNTO
            };
            if (simbolos[char]) {
                tokens.push({ type: simbolos[char], value: char, linea, col });
                pos++;
                col++;
                continue;
            }

            if (char === "'") {
                let startPos = pos + 1;
                let endPos = code.indexOf("'", startPos);
                if (endPos === -1) {
                    return { error: `Error Léxico (L:${linea}, C:${col}): String no cerrado.` };
                }
                let value = code.substring(startPos, endPos);
                tokens.push({ type: TokenType.STRING, value, linea, col });
                let len = endPos - pos + 1;
                pos = endPos + 1;
                col += len;
                continue;
            }
            
            if (char === 'F' && code.substring(pos, pos + 4) === 'FIN!') {
                 tokens.push({ type: TokenType.FIN_FUNCION, value: 'FIN!', linea, col });
                 pos += 4; col += 4;
                 continue;
            }
             if (char === 'F' && code.substring(pos, pos + 4) === 'FIN;') {
                 tokens.push({ type: TokenType.FIN_PARA, value: 'FIN;', linea, col });
                 pos += 4; col += 4;
                 continue;
            }

            if (esLetra(char)) {
                let startPos = pos;
                while (pos < code.length && (esAlfanumerico(code[pos]) || code[pos] === '_')) {
                    pos++;
                }
                let value = code.substring(startPos, pos);
                let type = KEYWORDS[value] || TokenType.IDENTIFICADOR;
                tokens.push({ type, value, linea, col });
                col += value.length;
                continue;
            }

            return { error: `Error Léxico (L:${linea}, C:${col}): Carácter no reconocido '${char}'.` };
        }

        tokens.push({ type: TokenType.EOF, value: 'EOF', linea, col });
        return { tokens };
    }

    // ==================================================================
    // 4. ANALIZADOR SINTÁCTICO (Generador de AST) - MODO ESTRICTO
    // ==================================================================

    let parserTokens = [];
    let parserPos = 0;

    function parseError(token, mensaje) {
        return `Error Sintáctico (L:${token.linea}, C:${token.col}): ${mensaje}. Se obtuvo '${token.value}'.`;
    }

    const peek = () => parserTokens[parserPos];
    const previous = () => parserTokens[parserPos - 1];
    const isAtEnd = () => peek().type === TokenType.EOF;
    const check = (type) => peek().type === type;
    const advance = () => { if (!isAtEnd()) parserPos++; return previous(); };
    
    const match = (...types) => {
        for (const type of types) {
            if (check(type)) {
                advance();
                return true;
            }
        }
        return false;
    };
    
    const consume = (type, mensaje) => {
        if (check(type)) return advance();
        throw new Error(parseError(peek(), mensaje));
    };

    function analizarSintactico(tokens) {
        parserTokens = tokens;
        parserPos = 0;
        let ast = [];
        
        try {
            consume(TokenType.FUNCION, "Se esperaba 'FUNCION'");
            consume(TokenType.MAIN, "Se esperaba 'main'");
            consume(TokenType.PAREN_IZQ, "Se esperaba '(' después de 'main'");
            consume(TokenType.PAREN_DER, "Se esperaba ')' después de 'main'");
            consume(TokenType.LLAVE_IZQ, "Se esperaba '{' para iniciar el bloque 'main'");
            
            ast = parseBlock();

            consume(TokenType.LLAVE_DER, "Se esperaba '}' para cerrar el bloque 'main'");
            consume(TokenType.FIN_FUNCION, "Se esperaba 'FIN!' al final del programa");
            consume(TokenType.EOF, "Se esperaba el fin del archivo después de 'FIN!'");

            return { ast: { type: 'Program', body: ast } };
        } catch (error) {
            return { error: error.message };
        }
    }

    function parseBlock() {
        let statements = [];
        while (!check(TokenType.LLAVE_DER) && !isAtEnd()) {
            statements.push(parseStatement());
        }
        return statements;
    }

    function parseStatement() {
        if (match(TokenType.VAR)) return parseVarDeclaration();
        if (match(TokenType.IMPRIMIR)) return parseImprimirStatement();
        if (match(TokenType.LEER)) return parseLeerStatement();
        if (match(TokenType.DESCARGAR)) return parseDescargarStatement();
        if (match(TokenType.PARA)) return parseParaCadaStatement();
        if (match(TokenType.SI)) return parseSiStatement();
        if (match(TokenType.PUNTO_COMA)) { return { type: 'EmptyStatement' }; } 
        
        throw new Error(parseError(peek(), "Instrucción no reconocida"));
    }

    // --- Parser con ; OBLIGATORIO ---

    function parseVarDeclaration() {
        const name = consume(TokenType.IDENTIFICADOR, "Se esperaba un nombre para la variable").value;
        consume(TokenType.ASIGNAR, "Se esperaba '=' después del nombre de la variable");
        
        let initializer = null;
        if (check(TokenType.STRING)) {
            initializer = { type: 'Literal', value: advance().value };
        } else if (check(TokenType.CORCH_IZQ)) {
            initializer = { type: 'ArrayLiteral', elements: [] };
            advance(); // Consume '['
            while (!check(TokenType.CORCH_DER) && !isAtEnd()) {
                const url = consume(TokenType.STRING, "Se esperaba un string (URL) en el array").value;
                consume(TokenType.AS, "Se esperaba 'AS' después de la URL");
                const nombre = consume(TokenType.STRING, "Se esperaba un string (nombre) después de 'AS'").value;
                initializer.elements.push({ url, nombre });
                if (!match(TokenType.COMA)) break;
            }
            consume(TokenType.CORCH_DER, "Se esperaba ']' para cerrar el array");
        } else {
            throw new Error(parseError(peek(), "Se esperaba un valor (string o array) para la variable"));
        }
        
        consume(TokenType.PUNTO_COMA, "Se esperaba ';' al final de la declaración VAR");
        return { type: 'VarDeclaration', name, initializer };
    }

    function parseImprimirStatement() {
        const value = consume(TokenType.STRING, "Se esperaba un string después de 'IMPRIMIR'").value;
        consume(TokenType.PUNTO_COMA, "Se esperaba ';' al final de IMPRIMIR");
        return { type: 'ImprimirStatement', value };
    }
    
    function parseLeerStatement() {
        const variable = consume(TokenType.IDENTIFICADOR, "Se esperaba un nombre de variable después de 'LEER'").value;
        consume(TokenType.PUNTO_COMA, "Se esperaba ';' al final de LEER");
        return { type: 'LeerStatement', variable };
    }

    function parseDescargarStatement() {
        const args = [];
        consume(TokenType.PAREN_IZQ, "Se esperaba '(' después de 'descargar'");
        
        args.push(parseExpression());
        consume(TokenType.COMA, "Se esperaba ',' después del primer argumento");
        args.push(parseExpression());
        consume(TokenType.COMA, "Se esperaba ',' después del segundo argumento");
        args.push(parseExpression());
        consume(TokenType.COMA, "Se esperaba ',' después del tercer argumento");
        args.push(parseExpression());
        
        consume(TokenType.PAREN_DER, "Se esperaba ')' después de los argumentos de 'descargar'");
        consume(TokenType.PUNTO_COMA, "Se esperaba ';' al final de descargar");
        
        return { type: 'DescargarStatement', arguments: args };
    }
    
    function parseParaCadaStatement() {
        consume(TokenType.CADA, "Se esperaba 'CADA' después de 'PARA'");
        const iteratorVar = consume(TokenType.IDENTIFICADOR, "Se esperaba un nombre de variable (iterador)").value;
        consume(TokenType.EN, "Se esperaba 'EN'");
        const arrayVar = consume(TokenType.IDENTIFICADOR, "Se esperaba un nombre de variable (array)").value;
        consume(TokenType.HACER, "Se esperaba 'HACER'");
        consume(TokenType.LLAVE_IZQ, "Se esperaba '{' para iniciar el bloque 'PARA CADA'");
        
        const body = parseBlock();
        
        consume(TokenType.LLAVE_DER, "Se esperaba '}' para cerrar el bloque 'PARA CADA'");
        consume(TokenType.FIN_PARA, "Se esperaba 'FIN;' al final del bloque 'PARA CADA'");
        
        return { type: 'ParaCadaStatement', iteratorVar, arrayVar, body };
    }
    
    function parseSiStatement() {
        const condition = consume(TokenType.IDENTIFICADOR, "Se esperaba una variable como condición para 'SI'").value;
        consume(TokenType.ENTONCES, "Se esperaba 'ENTONCES' después de la condición");
        consume(TokenType.LLAVE_IZQ, "Se esperaba '{' para iniciar el bloque 'SI'");
        
        const body = parseBlock();
        
        consume(TokenType.LLAVE_DER, "Se esperaba '}' para cerrar el bloque 'SI'");
        
        return { type: 'SiStatement', condition, body };
    }
    
    function parseExpression() {
        if (match(TokenType.STRING)) {
            return { type: 'Literal', value: previous().value };
        }
        if (match(TokenType.TIPO_DATO)) {
             return { type: 'Literal', value: previous().value };
        }
        
        if (match(TokenType.IDENTIFICADOR)) {
            const id = previous().value;
            if (match(TokenType.PUNTO)) {
                const property = consume(TokenType.IDENTIFICADOR, "Se esperaba nombre de propiedad (url, nombre) después de '.'").value;
                return { type: 'MemberExpression', object: id, property: property };
            }
            return { type: 'Identifier', name: id };
        }

        throw new Error(parseError(peek(), "Se esperaba una expresión (variable, string, tipo)"));
    }


    // ==================================================================
    // 5. INTÉRPRETE DE EJECUCIÓN (AST)
    // ==================================================================

    class Environment {
        constructor() { this.variables = new Map(); }
        define(name, value) { this.variables.set(name, value); }
        assign(name, value) {
            this.variables.set(name, value);
        }
        get(name) {
            if (!this.variables.has(name)) {
                if (name.includes('.')) { 
                     const [objName, propName] = name.split('.');
                     const obj = this.get(objName);
                     if (typeof obj !== 'object' || obj === null) {
                         throw new Error(`Ejecución: '${objName}' no es un objeto.`);
                     }
                     return obj[propName];
                }
                throw new Error(`Ejecución: Variable no definida '${name}'.`);
            }
            return this.variables.get(name);
        }
    }

    function evaluateExpression(node, environment) {
        if (!node) return undefined;
        switch(node.type) {
            case 'Literal':
                return node.value;
            case 'Identifier':
                return environment.get(node.name);
            case 'MemberExpression':
                const object = environment.get(node.object); 
                if (typeof object !== 'object' || object === null) {
                    throw new Error(`Ejecución: '${node.object}' no es un objeto.`);
                }
                if(node.property === 'url' || node.property === 'nombre') {
                    return object[node.property];
                } else {
                    throw new Error(`Ejecución: Propiedad desconocida '${node.property}'.`);
                }
            default:
                throw new Error(`Ejecución: Expresión no reconocida '${node.type}'.`);
        }
    }


    async function* executionGenerator(astNode, environment) {
        if (!astNode) {
            return; // Ignorar nodos nulos
        }
        
        async function* askForInput(prompt, options) {
            let input;
            prompt.split('\n').forEach(line => writeToConsole(line, 'line-sim-output'));
            
            const validKeys = Object.keys(options); 
            const regex = new RegExp(`^(${validKeys.join('|')})$`); 

            while (true) {
                input = yield { type: 'input', prompt: "" }; 
                
                if (regex.test(input)) {
                    return options[input];
                } else {
                    writeToConsole(`> Opción no válida. Intente de nuevo.`, 'line-error');
                    yield { type: 'input_prompt_only', prompt: "" };
                }
            }
        }
        
        switch (astNode.type) {
            case 'Program':
                for (const statement of astNode.body) {
                    yield* executionGenerator(statement, environment);
                }
                break;
            case 'EmptyStatement':
                break;
            case 'VarDeclaration':
                let initValue;
                if (astNode.initializer.type === 'Literal') {
                    initValue = astNode.initializer.value;
                } else if (astNode.initializer.type === 'ArrayLiteral') {
                    initValue = astNode.initializer.elements;
                }
                environment.define(astNode.name, initValue);
                break;
            case 'ImprimirStatement':
                writeToConsole(astNode.value, 'line-sim-output');
                break;

            case 'LeerStatement':
                let lastLineText = "";
                if (consoleOutput.lastChild && consoleOutput.lastChild.classList.contains('line-sim-output')) {
                    lastLineText = consoleOutput.lastChild.textContent;
                    consoleOutput.removeChild(consoleOutput.lastChild);
                }
                
                const input = yield { type: 'input', prompt: lastLineText }; 
                
                environment.assign(astNode.variable, input);

                if (lastLineText.includes('URL')) {
                    writeToConsole(`> URL recibida.`, 'line-info');
                }
                break;
            
            case 'DescargarStatement':
                const args = [];
                for(const argNode of astNode.arguments) {
                    const evaluatedArg = evaluateExpression(argNode, environment);
                    args.push(evaluatedArg);
                }
                const [url, formato, nombre, ruta] = args;
                
                if (typeof url === 'undefined') {
                    throw new Error(`La URL es 'undefined'. Verifica que la variable 'link' o 'playlistURL' se haya leído (LEER) correctamente.`);
                }

                if (formato.trim() === '') {
                    let loopCount = (url.toLowerCase().includes('playlist')) ? 3 : 1;
                    if (loopCount > 1) {
                         writeToConsole(`> Playlist detectada. Descargando ${loopCount} videos...`, 'line-info');
                    }
                    
                    for (let i = 0; i < loopCount; i++) {
                        let videoNombre = (loopCount > 1) ? `${nombre}_${i+1}` : nombre;
                        if(loopCount > 1) writeToConsole(`--- Video ${i+1} de ${loopCount} (${videoNombre}) ---`, 'line-warn');

                        // ***** NUEVOS FORMATOS *****
                        const formatoMap = { 
                            '1': 'mp3', 
                            '2': 'mp4', 
                            '3': 'mkv', 
                            '4': 'wav', 
                            '5': 'avi', 
                            '6': 'flac',
                            '7': 'webm'
                        };
                        const formatoPrompt = '> Seleccione formato:\n' +
                                            '1. mp3 (Audio)\n' +
                                            '2. mp4 (Video)\n' +
                                            '3. mkv (Video)\n' +
                                            '4. wav (Audio)\n' +
                                            '5. avi (Video)\n' +
                                            '6. flac (Audio)\n' +
                                            '7. webm (Video)';
                        const formatoSeleccionado = yield* askForInput(formatoPrompt, formatoMap); 

                        // ***** LÓGICA DE CALIDAD MEJORADA *****
                        let calidadSeleccionada;
                        const audioFormats = ['mp3', 'wav', 'flac'];
                        
                        if (audioFormats.includes(formatoSeleccionado)) {
                            const calidadAudioMap = { '1': '128kbps', '2': '192kbps', '3': '320kbps' };
                            calidadSeleccionada = yield* askForInput(
                                '> Seleccione calidad de audio:\n1. 128kbps (Estándar)\n2. 192kbps (Buena)\n3. 320kbps (Alta Calidad)',
                                calidadAudioMap
                            );
                        } else { // Video
                            const calidadVideoMap = { '1': '360p', '2': '720p', '3': '1080p' };
                            calidadSeleccionada = yield* askForInput(
                                '> Seleccione calidad de video:\n1. 360p (Baja)\n2. 720p (HD)\n3. 1080p (Full HD)',
                                calidadVideoMap
                            );
                        }
                        
                        writeToConsole(`> Descargando '${videoNombre}' (${formatoSeleccionado} @ ${calidadSeleccionada})...`, 'line-info');
                        await sleep(1500);
                        writeToConsole(`> Descarga completada en ${ruta}`, 'line-success');
                    }
                } else {
                    writeToConsole(`> Descargando (lote) '${nombre}.${formato}'...`, 'line-info');
                    await sleep(1000); 
                    writeToConsole(`> Descarga completada en ${ruta}`, 'line-success');
                }
                break;

            case 'ParaCadaStatement':
                const array = environment.get(astNode.arrayVar);
                if (!Array.isArray(array)) {
                    throw new Error(`Ejecución: '${astNode.arrayVar}' no es un array (en PARA CADA).`);
                }
                const loopEnv = new Environment();
                loopEnv.variables = new Map(environment.variables);
                for (const item of array) {
                    loopEnv.define(astNode.iteratorVar, item);
                    for (const statement of astNode.body) {
                        yield* executionGenerator(statement, loopEnv);
                    }
                }
                break;
            case 'SiStatement':
                const conditionValue = environment.get(astNode.condition);
                if (conditionValue && conditionValue.trim() !== '') { 
                    const ifEnv = new Environment(); 
                    ifEnv.variables = new Map(environment.variables);
                    for (const statement of astNode.body) {
                        yield* executionGenerator(statement, ifEnv);
                    }
                }
                break;
            default:
                throw new Error(`Ejecución: Nodo AST no reconocido '${astNode.type}'.`);
        }
    }

    // ==================================================================
    // 6. CONTROLADOR PRINCIPAL (UI, Consola, Pestañas)
    // ==================================================================

    function init() {
        Object.keys(tabData).forEach(filename => createFileInSidebar(filename));
        switchFile(activeFile);
        
        fileList.addEventListener('click', handleFileClick);
        editor.addEventListener('input', handleEditorInput);
        consoleInput.addEventListener('keydown', handleConsoleKeyDown);
        consoleWrapper.addEventListener('click', () => consoleInput.focus());
        fileUploader.addEventListener('change', handleFileUpload);
        runButton.addEventListener('click', runAnalysisAndExecution);
        uploadButton.addEventListener('click', () => fileUploader.click());
        
        writeToConsole('--- YTDOWNLOAD Studio ---', 'line-warn');
        writeToConsole('Seleccione un archivo y presione "Ejecutar Código".');
        
        setConsoleMode('idle');
    }

    function createFileInSidebar(filename) {
        const li = document.createElement('li');
        li.dataset.fileId = filename;
        li.textContent = filename;
        fileList.appendChild(li);
        return li;
    }

    function switchFile(filename) {
        activeFile = filename;
        
        document.querySelectorAll('.file-list li').forEach(li => {
            li.classList.toggle('active', li.dataset.fileId === filename);
        });
        
        editor.value = tabData[filename] || '';
        
        updateStatus('Listo');
        cancelProcess();
        consoleInput.focus();
    }

    function updateStatus(message, isError = false, isSuccess = false) {
        statusText.textContent = `Estado: ${message}`;
        statusText.classList.toggle('error', isError);
        statusText.classList.toggle('success', isSuccess);
    }
    
    // --- Manejadores de Eventos ---

    function handleFileClick(e) {
        if (e.target.tagName === 'LI') {
            const filename = e.target.dataset.fileId;
            if (filename !== activeFile) {
                switchFile(filename);
            }
        }
    }

    function handleEditorInput() {
        tabData[activeFile] = editor.value;
    }

    async function handleConsoleKeyDown(e) {
        if (e.key !== 'Enter') return;
        
        const input = consoleInput.value;
        consoleInput.value = '';
        
        if (consoleMode === 'command' && processInputResolve) {
            
            const currentPromptText = currentInputPrompt;
            setConsoleMode('processing'); 
            
            if (currentPromptText.trim() !== "") {
                writeToConsole(`> ${currentPromptText} ${input}`, 'line-sim-output');
            } else {
                writeToConsole(`> ${input}`, 'line-sim-output'); 
            }
            
            processInputResolve(input); 
            processInputResolve = null;
        }
    }

    function handleFileUpload(e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
            const content = event.target.result;
            const filename = file.name;
            
            tabData[filename] = content;
            createFileInSidebar(filename);
            switchFile(filename);
        };
        reader.onerror = () => {
            writeToConsole(`Error leyendo el archivo ${file.name}`, 'line-error');
        };
        reader.readAsText(file);
        e.target.value = null; // Resetear
    }
    
    // --- Flujo de Ejecución ---

    function runAnalysisAndExecution() {
        const code = tabData[activeFile];
        
        consoleOutput.innerHTML = '';
        writeToConsole(`Iniciando análisis para ${activeFile}...`, 'line-info');
        
        const lexerResult = analizarLexico(code);
        if (lexerResult.error) {
            writeToConsole(lexerResult.error, 'line-error');
            updateStatus('Error Léxico', true);
            return;
        }
        writeToConsole('✓ Análisis Léxico completado.', 'line-success');
        
        const parserResult = analizarSintactico(lexerResult.tokens);
        if (parserResult.error) {
            writeToConsole(parserResult.error, 'line-error');
            updateStatus('Error Sintáctico', true);
            return;
        }
        writeToConsole('✓ Análisis Sintáctico completado.', 'line-success');
        updateStatus('Análisis exitoso', false, true);

        writeToConsole('→ Iniciando proceso de descarga...', 'line-warn');
        startProcess(parserResult.ast);
    }
    
    function startProcess(ast) {
        const environment = new Environment();
        currentProcess = executionGenerator(ast, environment);
        setConsoleMode('processing'); 
        advanceProcess(); 
    }

    async function advanceProcess(valueFromLastYield) { 
        if (!currentProcess) return;
        
        try {
            const result = await currentProcess.next(valueFromLastYield);
            
            if (result.done) {
                writeToConsole('--- Proceso finalizado ---', 'line-warn');
                updateStatus('Proceso completado', false, true);
                cancelProcess();
                return;
            }

            const value = result.value; 

            if (value && value.type) {
                if (value.type === 'input' || value.type === 'input_prompt_only') {
                    currentInputPrompt = value.prompt;
                    let visualPrompt = (currentInputPrompt.trim() !== "") ? `> ${currentInputPrompt} ` : "> ";
                    setConsoleMode('command', visualPrompt); 
                    
                    const nextValue = await new Promise(resolve => { 
                        processInputResolve = resolve; 
                    });
                    
                    advanceProcess(nextValue); 
                }
            } else {
                advanceProcess();
            }
            
        } catch (error) {
            console.error(error); // Log real para debugging
            writeToConsole(`Error de Ejecución: ${error.message}`, 'line-error');
            updateStatus('Error en Ejecución', true);
            cancelProcess();
        }
    }
    
    function cancelProcess() {
        setConsoleMode('idle'); 
        currentProcess = null;
        processInputResolve = null;
        currentInputPrompt = "";
    }

    function setConsoleMode(mode, promptOverride = null) {
        consoleMode = mode;
        const inputLine = consoleInput.parentElement;
        
        if (mode === 'command') { 
            promptText.textContent = promptOverride !== null ? promptOverride : "> ";
            inputLine.style.display = 'flex'; 
            consoleInput.focus();
        } else { 
            promptText.textContent = "";
            inputLine.style.display = 'none'; 
        }
    }

    // ==================================================================
    // 7. UTILIDADES
    // ==================================================================

    function writeToConsole(message, className = '') {
        const line = document.createElement('div');
        line.className = 'line';
        if (className) {
            line.classList.add(className);
        }
        line.textContent = message;
        consoleOutput.appendChild(line);
        consoleWrapper.scrollTop = consoleWrapper.scrollHeight;
    }
    
    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    // --- Arrancar la aplicación ---
    init();

    </script>
</body>
</html>
